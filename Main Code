#include <Wire.h>              // IR Sensor
#include "DFRobot_URM09.h"     // Ultrasonic Sensor
#include <MYUM7.h>             // IMU UM7
#include <Adafruit_Sensor.h>   // IMU BNO055
#include <Adafruit_BNO055.h>   // IMU BNO055
#include <utility/imumaths.h>  // IMU BNO055

// ------- easy access vars --------
float goalie_speed = 0.6;
float striker_speed = 0.6;
bool striker = false;
float line_thresh = 200;  // 1023 = black, 100 = white

float nominal_robot_speed;
float robot_speed = nominal_robot_speed;

uint16_t BNO055_SAMPLERATE_DELAY_MS = 100;

Adafruit_BNO055 bno = Adafruit_BNO055(55, 0x28, &Wire);

#define TL_MOT Serial5
#define TR_MOT Serial1
#define BL_MOT Serial3
#define BR_MOT Serial2

// Create a URM09 object to communicate with I2C
DFRobot_URM09 URM09_FRONT;  // Create a URM09 object to communicate with I2C
DFRobot_URM09 URM09_BACK;   // Create a URM09 object to communicate with I2C
DFRobot_URM09 URM09_LEFT;   // Create a URM09 object to communicate with I2C
DFRobot_URM09 URM09_RIGHT;  // Create a URM09 object to communicate with I2C

int16_t dist_front;
int16_t dist_back;
int16_t dist_left;
int16_t dist_right;

int IR_map[8] = { 0, 5, 6, 7, 1, 2, 3, 4 };
float front_port_ang_map[8] = { 0, 90, 60, 30, 0, 330, 300, 270 };     //0, 270, 300, 330, 0, 30, 60, 90
float back_port_ang_map[8] = { 0, 270, 240, 210, 180, 150, 120, 90 };  //90, 120, 150, 180, 210, 240, 270

int max_port_back;
int max_port_front;
float max_port_front_val;
float max_port_back_val;
float max_port_val;
float max_port_left_val;
float max_port_right_val;
float port_ang;
float ball_ang;
float drive_ang;

float raw_heading = 0;
float init_heading = 0;
float processed_heading = 0;
float rotation;
float north;

float field_length = 219;
float field_width = 158;
float loc_x;
float loc_y;
float home_x;
float home_y;
const float striker_home_x = 91 + 8;
const float striker_home_y = 50 + 15;
const float goalie_home_x = 91;
const float goalie_home_y = 33;
float striker_home_speed_min = 0.5;
float striker_home_speed_max = 0.6;
float goalie_home_speed_min = 0.3;
float goalie_home_speed_max = 0.4;
const float goal_x = 79;
const float goal_y = 219 - 12 - 5;
float goal_ang;
float processed_goal_ang;

unsigned long init;
bool first_in_front = true;
long ball_in_front_start;

float bounce_back_thresh = 25;

const int FGS_pin = A16;  // Front GS_pin
const int LGS_pin = A8;   // Left GS_pin
const int RGS_pin = A17;  // Right GS_pin
const int BGS_pin = A15;  // Back GS_pin
int FGS_val = 0;
int LGS_val = 0;
int RGS_val = 0;
int BGS_val = 0;

int ball_capture_pin = A9;
float ball_capture_thresh = 10;
int ball_capture_val;
long time_last_captured;
float ball_capture_time = 200;

bool switch_on = false;
const int switch_pin = A13;
bool first_reset_heading = true;

int circle_const = 80;

float rot_const = 2;  // increase to rotate slower
bool opponent_block_x = false;
bool opponent_block_y = false;

// Wire.write(1-7) reads intensity of ports 1-7
// Wire.write(9) reads intensity of highest port.

void setMotorSpeed(float motor_speed, Stream &port) {  // Port is passed as reference as to modify real object
  int real_motor_speed = 3200 * motor_speed;
  if (real_motor_speed < 0) {
    port.write(0x86);                      // motor reverse command
    real_motor_speed = -real_motor_speed;  // make speed positive
  } else {
    port.write(0x85);  // motor forward command
  }
  port.write(real_motor_speed & 0x1F);
  port.write(real_motor_speed >> 5 & 0x7F);
}

void drive(float ang, float drive_speed) {
  float rotation = (processed_heading / 180) / rot_const;
  float ang_accepted;
  float TL_speed = 0;
  float TR_speed = 0;
  float BL_speed = 0;
  float BR_speed = 0;
  if (switch_on) {
    if (ang >= 0 && ang <= 45) {
      ang_accepted = 45 - ang;
      BR_speed = cos(toRadian(ang_accepted)) * drive_speed;
      TR_speed = sin(toRadian(ang_accepted)) * drive_speed;
      TL_speed = -cos(toRadian(ang_accepted)) * drive_speed;
      BL_speed = -sin(toRadian(ang_accepted)) * drive_speed;
    } else if (ang > 45 && ang <= 90) {
      ang_accepted = ang - 45;
      BR_speed = cos(toRadian(ang_accepted)) * drive_speed;
      TR_speed = -sin(toRadian(ang_accepted)) * drive_speed;
      TL_speed = -cos(toRadian(ang_accepted)) * drive_speed;
      BL_speed = sin(toRadian(ang_accepted)) * drive_speed;
    } else if (ang > 90 && ang <= 135) {
      ang_accepted = ang - 45;
      BR_speed = cos(toRadian(ang_accepted)) * drive_speed;
      TR_speed = -sin(toRadian(ang_accepted)) * drive_speed;
      TL_speed = -cos(toRadian(ang_accepted)) * drive_speed;
      BL_speed = sin(toRadian(ang_accepted)) * drive_speed;
    } else if (ang > 135 && ang <= 180) {
      ang_accepted = 225 - ang;
      BR_speed = -cos(toRadian(ang_accepted)) * drive_speed;
      TR_speed = -sin(toRadian(ang_accepted)) * drive_speed;
      TL_speed = cos(toRadian(ang_accepted)) * drive_speed;
      BL_speed = sin(toRadian(ang_accepted)) * drive_speed;
    } else if (ang > 180 && ang <= 225) {
      ang_accepted = 225 - ang;
      BR_speed = -cos(toRadian(ang_accepted)) * drive_speed;
      TR_speed = -sin(toRadian(ang_accepted)) * drive_speed;
      TL_speed = cos(toRadian(ang_accepted)) * drive_speed;
      BL_speed = sin(toRadian(ang_accepted)) * drive_speed;
    } else if (ang > 225 && ang <= 270) {
      ang_accepted = ang - 225;
      BR_speed = -cos(toRadian(ang_accepted)) * drive_speed;
      TR_speed = sin(toRadian(ang_accepted)) * drive_speed;
      TL_speed = cos(toRadian(ang_accepted)) * drive_speed;
      BL_speed = -sin(toRadian(ang_accepted)) * drive_speed;
    } else if (ang > 270 && ang <= 315) {
      ang_accepted = 315 - ang;
      BR_speed = -cos(toRadian(ang_accepted)) * drive_speed;
      TR_speed = sin(toRadian(ang_accepted)) * drive_speed;
      TL_speed = cos(toRadian(ang_accepted)) * drive_speed;
      BL_speed = -sin(toRadian(ang_accepted)) * drive_speed;
    } else if (ang > 315 && ang <= 360) {  // ang > 315 && ang <= 360
      ang_accepted = 405 - ang;
      BR_speed = cos(toRadian(ang_accepted)) * drive_speed;
      TR_speed = sin(toRadian(ang_accepted)) * drive_speed;
      TL_speed = -cos(toRadian(ang_accepted)) * drive_speed;
      BL_speed = -sin(toRadian(ang_accepted)) * drive_speed;
    }
    TL_speed = constrain(TL_speed + rotation, -1, 1);
    TR_speed = constrain(TR_speed + rotation, -1, 1);
    BL_speed = constrain(BL_speed + rotation, -1, 1);
    BR_speed = constrain(BR_speed + rotation, -1, 1);
  } else {
    BR_speed = 0;
    TR_speed = 0;
    BL_speed = 0;
    TL_speed = 0;
  }

  setMotorSpeed(BR_speed, BR_MOT);
  setMotorSpeed(TL_speed, TL_MOT);
  setMotorSpeed(TR_speed, TR_MOT);
  setMotorSpeed(BL_speed, BL_MOT);

  // Serial.print("TL: ");
  // Serial.print(TL_speed);
  // Serial.print(", ");
  // Serial.print("TR: ");
  // Serial.print(TR_speed);
  // Serial.print(", ");
  // Serial.print("BL: ");
  // Serial.print(BL_speed);
  // Serial.print(", ");
  // Serial.print("BR: ");
  // Serial.print(BR_speed);
  // Serial.print(", ");
  // Serial.print("Rot: ");
  // Serial.print(rotation);
  //  Serial.print(", ");
  // Serial.print("ang: ");

  //polarity depends how you wire motors
  // Serial.println(ang);
}

void drive_turn(float ang, float drive_speed, int turn_dir, float rotation) {
  float TL_speed = 0;
  float TR_speed = 0;
  float BL_speed = 0;
  float BR_speed = 0;
  float ang_accepted;
  if (switch_on) {
    if (ang >= 0 && ang <= 45) {
      ang_accepted = 45 - ang;
      BR_speed = cos(toRadian(ang_accepted)) * drive_speed;
      TR_speed = sin(toRadian(ang_accepted)) * drive_speed;
      TL_speed = -cos(toRadian(ang_accepted)) * drive_speed;
      BL_speed = -sin(toRadian(ang_accepted)) * drive_speed;
    } else if (ang > 45 && ang <= 90) {
      ang_accepted = ang - 45;
      BR_speed = cos(toRadian(ang_accepted)) * drive_speed;
      TR_speed = -sin(toRadian(ang_accepted)) * drive_speed;
      TL_speed = -cos(toRadian(ang_accepted)) * drive_speed;
      BL_speed = sin(toRadian(ang_accepted)) * drive_speed;
    } else if (ang > 90 && ang <= 135) {
      ang_accepted = ang - 45;
      BR_speed = cos(toRadian(ang_accepted)) * drive_speed;
      TR_speed = -sin(toRadian(ang_accepted)) * drive_speed;
      TL_speed = -cos(toRadian(ang_accepted)) * drive_speed;
      BL_speed = sin(toRadian(ang_accepted)) * drive_speed;
    } else if (ang > 135 && ang <= 180) {
      ang_accepted = 225 - ang;
      BR_speed = -cos(toRadian(ang_accepted)) * drive_speed;
      TR_speed = -sin(toRadian(ang_accepted)) * drive_speed;
      TL_speed = cos(toRadian(ang_accepted)) * drive_speed;
      BL_speed = sin(toRadian(ang_accepted)) * drive_speed;
    } else if (ang > 180 && ang <= 225) {
      ang_accepted = 225 - ang;
      BR_speed = -cos(toRadian(ang_accepted)) * drive_speed;
      TR_speed = -sin(toRadian(ang_accepted)) * drive_speed;
      TL_speed = cos(toRadian(ang_accepted)) * drive_speed;
      BL_speed = sin(toRadian(ang_accepted)) * drive_speed;
    } else if (ang > 225 && ang <= 270) {
      ang_accepted = ang - 225;
      BR_speed = -cos(toRadian(ang_accepted)) * drive_speed;
      TR_speed = sin(toRadian(ang_accepted)) * drive_speed;
      TL_speed = cos(toRadian(ang_accepted)) * drive_speed;
      BL_speed = -sin(toRadian(ang_accepted)) * drive_speed;
    } else if (ang > 270 && ang <= 315) {
      ang_accepted = 315 - ang;
      BR_speed = -cos(toRadian(ang_accepted)) * drive_speed;
      TR_speed = sin(toRadian(ang_accepted)) * drive_speed;
      TL_speed = cos(toRadian(ang_accepted)) * drive_speed;
      BL_speed = -sin(toRadian(ang_accepted)) * drive_speed;
    } else if (ang > 315 && ang <= 360) {  // ang > 315 && ang <= 360
      ang_accepted = 405 - ang;
      BR_speed = cos(toRadian(ang_accepted)) * drive_speed;
      TR_speed = sin(toRadian(ang_accepted)) * drive_speed;
      TL_speed = -cos(toRadian(ang_accepted)) * drive_speed;
      BL_speed = -sin(toRadian(ang_accepted)) * drive_speed;
    }
    TL_speed = constrain(TL_speed + rotation, -1, 1);
    TR_speed = constrain(TR_speed + rotation, -1, 1);
    BL_speed = constrain(BL_speed + rotation, -1, 1);
    BR_speed = constrain(BR_speed + rotation, -1, 1);
  } else {
    TL_speed = 0;
    TR_speed = 0;
    BL_speed = 0;
    BR_speed = 0;
  }

  // Serial.print("TL: ");
  // Serial.print(TL_speed);
  // Serial.print(", ");
  // Serial.print("TR: ");
  // Serial.print(TR_speed);
  // Serial.print(", ");
  // Serial.print("BL: ");
  // Serial.print(BL_speed);
  // Serial.print(", ");
  // Serial.print("BR: ");
  // Serial.println(BR_speed);

  setMotorSpeed(BR_speed, BR_MOT);
  setMotorSpeed(TL_speed, TL_MOT);
  setMotorSpeed(TR_speed, TR_MOT);
  setMotorSpeed(BL_speed, BL_MOT);
}

void strikerFunc() {

  whiteLine();

  robot_speed = nominal_robot_speed;

  if (ballDetected()) {  // Robot sees ball

    if (ballCaptured() && loc_y > field_length / 2 && !lineDetected()) {
      score();
    } else {
      if (ball_ang < 30) {
        drive_ang = ball_ang * (1 - max_port_val / 145);
      } else if (ball_ang > 330) {
        drive_ang = 360 - ((360 - ball_ang) * (1 - max_port_val / 125));
      } else {
        circleAroundBall();
      }

      setDriveBounds(10, 10, 10, 19);
      drive(drive_ang, robot_speed);
    }
  } else {
    goHome();  // No ball, return home
  }
}

void goalieFunc0() {

  robot_speed = nominal_robot_speed;

  if (ballDetected()) {
    // if (dist_back > goalie_home_y + bounce_back_thresh) {  // go back
    //   drive_ang = 180;
    // } else if (dist_back < goalie_home_y) {  // go forward
    //   drive_ang = 0;
    // } else {
    if (ball_ang > 345 || ball_ang < 15) {  // ball is in front
      robot_speed = 0;
      // if (first_in_front) {
      //   ball_in_front_start = millis();
      //   first_in_front = false;
      // }
      // long ball_in_front_elapsed = millis() - ball_in_front_start;
      // if (ball_in_front_elapsed > 3000) {
      //   drive_ang = ball_ang;
      // } else {
      //   robot_speed = 0;
      // }
    } else {
      first_in_front = true;
      // if (0){//ball_ang > 160 && ball_ang < 200) {
      //   drive_ang = 180;
      //   if (dist_back > goalie_home_y) {
      //     robot_speed = nominal_robot_speed * 0.8;
      //   } else {
      //     robot_speed = 0.3;
      //   }
      // }
      if (ball_ang > 180) {  // ball is on the left
        drive_ang = 270;
      } else {  // ball is on the right
        drive_ang = 90;
      }
    }
    //}

    // setDriveBounds(10, 10, 10, 19);
    drive(drive_ang, robot_speed);
  } else {
    goHome();
  }
}

void goalieFunc() {

  robot_speed = nominal_robot_speed;

  // Serial.println(loc_x);

  if (ballDetected()) {
    // Serial.println(dist_back);

    if (loc_x > 131 && ball_ang < 180) {  // 182 / 2 - 80 / 2 = 51, 182 / 2 + 80 / 2 = 131
      robot_speed = 0;
      // Serial.println("goal end");
    } else if (loc_x < 51 && ball_ang > 180) {
      robot_speed = 0;
      // Serial.println("goal_end");
    } else {
      // Serial.println("in play");
      if (dist_back > goalie_home_y + bounce_back_thresh) {  // go back
        drive_ang = 180;
        // Serial.println("go back");
      } else if (dist_back < goalie_home_y) {  // go forward
        drive_ang = 0;
        // Serial.println("go forward");
      } else {
        // Serial.println("-");
        if (ball_ang > 345 || ball_ang < 15) {  // ball is in front
          robot_speed = 0;
        } 
        else if (ball_ang < 195 && ball_ang > 165) { // ball is in back
          robot_speed = 0;
          // drive_ang = 180;
          // robot_speed = nominal_robot_speed * 0.6;
          }
          else { // ball on the sides semi in front
          if (ball_ang > 180) {  // ball is on the left
            drive_ang = 270;
          } else {  // ball is on the right
            drive_ang = 90;
          }
        }
      }
    }

    // if (opponent_block_x || opponent_block_y) {
    //   robot_speed = nominal_robot_speed * 0.7;
    // }

    Serial.print(drive_ang); Serial.print(", ");
    Serial.println(robot_speed);
    drive(drive_ang, robot_speed);
  } else {
    goHome();
  }
}

void loop() {

  updateData();

  if (striker) {
    strikerFunc();
  } else {
    goalieFunc();
  }

  // printData();
}

void updateData() {

  ball_capture_val = analogRead(ball_capture_pin);

  getBallAng();

  if (striker) {
    home_x = striker_home_x;
    home_y = striker_home_y;
    nominal_robot_speed = striker_speed;
  } else {
    nominal_robot_speed = goalie_speed;
    home_x = goalie_home_x;
    home_y = goalie_home_y;
  }

  FGS_val = analogRead(FGS_pin);
  LGS_val = analogRead(LGS_pin);
  RGS_val = analogRead(RGS_pin);
  BGS_val = analogRead(BGS_pin);

  switch_on = digitalRead(switch_pin);

  if (dist_left + dist_right < 45) {
    opponent_block_x = true;
  } else {
    opponent_block_x = false;
  }
  if (dist_front + dist_back < 45) {
    opponent_block_y = true;
  } else {
    opponent_block_y = false;
  }

  sensors_event_t orientationData;
  bno.getEvent(&orientationData, Adafruit_BNO055::VECTOR_EULER);
  raw_heading = orientationData.orientation.x;  // - starting_ang;
  if (switch_on) {
    if (first_reset_heading) {
      init_heading = raw_heading;
      first_reset_heading = false;
    }
    processed_heading = raw_heading - init_heading;  // - starting_ang;
  } else {
    first_reset_heading = true;
    processed_heading = raw_heading;
  }

  if (processed_heading > 180) {
    processed_heading -= 360;
  }

  dist_front = URM09_FRONT.getDistance();
  dist_back = URM09_BACK.getDistance();
  dist_left = URM09_LEFT.getDistance();
  dist_right = URM09_RIGHT.getDistance();

  if ((dist_left + dist_right) < 80) {
    loc_x = home_x;  // disregard x-axis , only y-axis to home
  } else {
    loc_x = dist_left < dist_right ? dist_left : (24 + field_width) - dist_right;  // (dist_left + (182-dist_right))/2;
  }
  if ((dist_back + dist_front) < 80) {
    loc_y = home_y;
  } else {
    loc_y = dist_back < dist_front ? dist_back : (24 + field_length) - dist_front;  // (dist_back + (243-dist_front))/2;
  }
}

void score() {
  float delta_goal_y = goal_y - loc_y;
  float delta_goal_x = goal_x - loc_x;

  int turn_direction;
  float turn_rotation;

  if (dist_left < dist_right) {
    goal_ang = 30;
  } else {
    goal_ang = 330;
  }

  processed_goal_ang = goal_ang;

  if (goal_ang < 0) {
    goal_ang += 360;
  }
  if (goal_ang < 180) {
    turn_direction = 1;
  } else {
    turn_direction = -1;
  }

  if (processed_goal_ang > 180) {
    processed_goal_ang -= 360;
  }

  turn_rotation = ((processed_heading - processed_goal_ang) / 180) / rot_const;

  drive_turn(goal_ang, striker_speed, turn_direction, turn_rotation);
}

void goHome() {
  float home_delta_x = home_x - loc_x;  // field delta x
  float home_delta_y = home_y - loc_y;  // field delta y
  float home_ang = atan2(home_delta_x, home_delta_y) * RAD_TO_DEG;
  float home_speed = sqrt(sq(home_delta_x) + sq(home_delta_y)) / 150;  // might need to reduce 150, 150 is max pythag dist it can be

  float home_speed_min;
  float home_speed_max;

  float homing_ang = 0;
  float homing_speed = 0;

  if (striker) {
    home_speed_min = striker_home_speed_min;
    home_speed_max = striker_home_speed_max;
  } else {
    home_speed_min = goalie_home_speed_min;
    home_speed_max = goalie_home_speed_max;
  }

  if (sqrt(sq(home_delta_x) + sq(home_delta_y)) < 10) {
    homing_speed = 0;
  } else {
    homing_ang = home_ang;
    homing_speed = constrain(home_speed, home_speed_min, home_speed_max);
  }
  if (homing_ang < 0) {
    homing_ang += 360;
  }
  drive(homing_ang, homing_speed);
}

void circleAroundBall() {
  // if (dist_left < 30) {  // Closer to left wall
  //   drive_ang = ball_ang * (1 - (max(max_port_front_val, max_port_back_val) / 125));
  // } else if (dist_right < 30) {  // Closer to right wall
  //   drive_ang = ball_ang + (90 * min((max(max_port_front_val, max_port_back_val) / 80), 1));
  // Robot in the middle of field
  if (ball_ang < 180) {
    drive_ang = ball_ang + (90 * min((max_port_val / circle_const), 1));
  } else {
    drive_ang = ball_ang - (90 * min((max_port_val / circle_const), 1));  // drive_ang = ball_ang * (1 - (max(max_port_front_val, max_port_back_val) / 125));
  }
}

void whiteLine() {
  if (lineDetected()) {
    long start = millis();
    long elapsed = millis() - start;
    while (elapsed < 500) {  // Once touch line, go home for 1 second
      elapsed = millis() - start;
      updateData();
      goHome();
    }
  }
}

void setDriveBounds(float frontBoundDist, float leftBoundDist, float rightBoundDist, float backBoundDist) {
  // Closer it is to wall, the higher the speed correction is (will slow down)
  float robot_radius = 11;
  float xDrive;
  float yDrive;

  if (opponent_block_x) {
    xDrive = sin((drive_ang / 180) * 3.14159) * robot_speed;
    yDrive = constrain(cos((drive_ang / 180) * 3.14159) * robot_speed, (((backBoundDist + robot_radius) - (float)dist_back) / backBoundDist), (((float)dist_front / frontBoundDist)));
    // Serial.println("opponent interfere x-axis");                              // Stops when something in front, but never go backwards(((float)dist_front-30) / 19));
  } else if (opponent_block_y) {
    yDrive = cos((drive_ang / 180) * 3.14159) * robot_speed;
    xDrive = constrain(sin((drive_ang / 180) * 3.14159) * robot_speed, (((leftBoundDist + robot_radius) - (float)dist_left) / leftBoundDist), (((float)dist_right - (robot_radius + rightBoundDist)) / rightBoundDist));  // increase integer numerator
    // Serial.println("opponent interfere y-axis");
  } else {
    xDrive = constrain(sin((drive_ang / 180) * 3.14159) * robot_speed, (((leftBoundDist + robot_radius) - (float)dist_left) / leftBoundDist), (((float)dist_right - (robot_radius + rightBoundDist)) / rightBoundDist));  // increase integer numerator
    yDrive = constrain(cos((drive_ang / 180) * 3.14159) * robot_speed, (((backBoundDist + robot_radius) - (float)dist_back) / backBoundDist), (((float)dist_front / frontBoundDist)));                                    // Stops when something in front, but never go backwards(((float)dist_front-30) / 19));
    // Serial.println("no interference");
  }

  xDrive = constrain(xDrive, -robot_speed, robot_speed);
  yDrive = constrain(yDrive, -robot_speed, robot_speed);
  // if grayscale then yDrive = 0
  robot_speed = sqrt((xDrive * xDrive) + (yDrive * yDrive));
  drive_ang = (atan2(xDrive, yDrive) * RAD_TO_DEG);  // inverse tangent that preserves the sign
  if (drive_ang < 0) {
    drive_ang += 360;
  }
  // Serial.print(xDrive); Serial.print(", ");
  // Serial.println(yDrive);
}

float getBallAng() {

  max_port_back = IRWriteCommand(8, 1);
  max_port_front = IRWriteCommand(8, 2);

  max_port_front_val = IRWriteCommand(9, 2);
  max_port_back_val = IRWriteCommand(9, 1);

  bool special = false;

  if (max_port_front_val >= max_port_back_val) {  // Ball Detected at Front Sensor

    max_port_val = max_port_front_val;
    port_ang = front_port_ang_map[max_port_front];

    if (max_port_front == 7) {  // Special case 1
      max_port_right_val = IRWriteCommand(IR_map[max_port_front - 1], 2);
      max_port_left_val = IRWriteCommand(IR_map[1], 1);
      if (max_port_left_val >= max_port_right_val) {
        special = true;
        ball_ang = 270;
      }
    } else if (max_port_front == 1) {  // Special case 2
      max_port_left_val = IRWriteCommand(IR_map[max_port_front + 1], 2);
      max_port_right_val = IRWriteCommand(IR_map[7], 1);
      if (max_port_right_val >= max_port_left_val) {
        special = true;
        ball_ang = 90;
      }
    } else {
      max_port_left_val = IRWriteCommand(IR_map[max_port_front + 1], 2);
      max_port_right_val = IRWriteCommand(IR_map[max_port_front - 1], 2);
    }

  } else {  // Ball Detected at Back Sensor

    max_port_val = max_port_back_val;
    port_ang = back_port_ang_map[max_port_back];

    if (max_port_back == 7) {  // Special case 1
      max_port_left_val = IRWriteCommand(IR_map[1], 2);
      max_port_right_val = IRWriteCommand(IR_map[max_port_back - 1], 1);
      if (max_port_left_val >= max_port_right_val) {
        special = true;
        ball_ang = 90;
      }
    } else if (max_port_back == 1) {  // Special case 2
      max_port_right_val = IRWriteCommand(IR_map[7], 2);
      max_port_left_val = IRWriteCommand(IR_map[max_port_back + 1], 1);
      if (max_port_right_val >= max_port_left_val) {
        special = true;
        ball_ang = 270;
      }
    } else {
      max_port_left_val = IRWriteCommand(IR_map[max_port_back + 1], 1);
      max_port_right_val = IRWriteCommand(IR_map[max_port_back - 1], 1);
    }
  }

  // Serial.print(max_port_left_val); Serial.print(", ");
  // Serial.println(max_port_right_val);

  if (!special) {
    // Getting the ball angle
    if (max_port_right_val >= max_port_left_val) {  // Ball between right and center ports
      ball_ang = port_ang + (15 * (1 - ((max_port_val - max_port_right_val) / (max_port_val - max_port_left_val))));
    } else {  // Ball between left and center ports
      ball_ang = port_ang - (15 * (1 - ((max_port_val - max_port_left_val) / (max_port_val - max_port_right_val))));
    }
    if (ball_ang < 0) {
      ball_ang += 360;
    }
  }

  return ball_ang;
}

int IRWriteCommand(byte command, byte port) {
  if (port == 1) {                 // Actually port 0 (front)
    Wire.beginTransmission(0x01);  // Tells Arduino to begin transmission to Teensy
    Wire.write(command);           // See pulse of IR ball - set to pulse mode
    Wire.endTransmission();
    Wire.requestFrom(0x01, 1);  // Acknowledge whether Teensy received above commands (1 byte)
    while (!Wire.available())   // Wait if I2C not available
      ;
    return Wire.read();
  } else if (port == 2) {           // Actually port 1 (back)
    Wire2.beginTransmission(0x01);  // Tells Arduino to begin transmission to Teensy
    Wire2.write(command);           // See pulse of IR ball - set to pulse mode
    Wire2.endTransmission();
    Wire2.requestFrom(0x01, 1);  // Acknowledge whether Teensy received above commands (1 byte)
    while (!Wire2.available())   // Wait if I2C not available
      ;
    return Wire2.read();
  } else {
    return -1;
  }
}

bool ballDetected() {
  return max_port_val > 5;
}

bool ballCaptured() {
  if (ball_capture_val >= ball_capture_thresh) {
    time_last_captured = millis();
  }
  return millis() - time_last_captured < ball_capture_time;
}

bool lineDetected() {
  return (FGSDetected() || LGSDetected() || RGSDetected() || BGSDetected());
}

bool FGSDetected() {
  return FGS_val <= line_thresh;
}

bool LGSDetected() {
  return LGS_val <= line_thresh;
}

bool RGSDetected() {
  return RGS_val <= line_thresh;
}

bool BGSDetected() {
  return BGS_val <= line_thresh;
}

float toRadian(float ang) {
  return (ang / 180) * 3.14159;
}

void printData() {

  // Head
  Serial.print(" ");
  Serial.print("Head:");
  Serial.print(processed_heading);
  Serial.print(" ");

  // IR
  Serial.print("  ");
  Serial.print("BALL ANG:");
  Serial.print(ball_ang);
  Serial.print(" ");
  Serial.print("FRONT IR:");
  Serial.print(max_port_front);
  Serial.print("  ");
  Serial.print("BACK IR:");
  Serial.print(max_port_back);
  Serial.print("  ");
  Serial.print("IR INT:");
  Serial.print(max_port_val);
  Serial.print(" ");
  Serial.print("Left Val:");
  Serial.print(max_port_left_val);
  Serial.print(" ");
  Serial.print("Mid Val:");
  Serial.print(max_port_val);
  Serial.print(" ");
  Serial.print("Right Val:");
  Serial.print(max_port_right_val);
  Serial.print(" ");
  Serial.print("Capture Val:");
  Serial.print(ball_capture_val);

  // US
  Serial.print("  ");
  Serial.print("FDist:");
  Serial.print(dist_front);
  Serial.print("  ");

  Serial.print("BDist:");
  Serial.print(dist_back);
  Serial.print("  ");

  Serial.print("LDist:");
  Serial.print(dist_left);
  Serial.print("  ");

  Serial.print("RDist:");
  Serial.print(dist_right);
  Serial.print("  ");

  Serial.print("LOCX:");
  Serial.print(loc_x);
  Serial.print(" ");

  // GS
  Serial.print("FGS:");
  Serial.print(FGS_val);
  Serial.print("  ");

  Serial.print("LGS:");
  Serial.print(LGS_val);
  Serial.print("  ");

  Serial.print("RGS:");
  Serial.print(RGS_val);
  Serial.print("  ");

  Serial.print("BGS:");
  Serial.print(BGS_val);
  Serial.println("  ");
}

void setup() {
  pinMode(13, OUTPUT);
  pinMode(FGS_pin, INPUT);
  pinMode(LGS_pin, INPUT);
  pinMode(RGS_pin, INPUT);
  pinMode(switch_pin, INPUT);
  digitalWrite(13, HIGH);
  Serial.begin(115200);  // Begin Serial for Serial Monitor
  Wire.begin();
  Wire1.begin();
  Wire2.begin();
  IRWriteCommand(14, 1);
  IRWriteCommand(14, 2);

  // -------- Motors ---------

  // Top Left Motor
  TL_MOT.begin(19200);
  delay(5);
  TL_MOT.write(0xAA);
  TL_MOT.write(0x83);  // Exit Safe Start
  // Top Right Motor
  TR_MOT.begin(19200);
  delay(5);
  TR_MOT.write(0xAA);
  TR_MOT.write(0x83);  // Exit Safe Start
  // Bottom Left Motor
  BL_MOT.begin(19200);
  delay(5);
  BL_MOT.write(0xAA);
  BL_MOT.write(0x83);  // Exit Safe Start
  // Bottom Right Motor
  BR_MOT.begin(19200);
  delay(5);
  BR_MOT.write(0xAA);
  BR_MOT.write(0x83);  // Exit Safe Start

  while (!URM09_BACK.begin(0x14)) {
    Serial.println("I2c device number error 0x14");
    delay(1000);
  }
  URM09_BACK.setModeRange(MEASURE_MODE_AUTOMATIC, MEASURE_RANG_500);
  delay(10);
  while (!URM09_FRONT.begin(0x12)) {
    Serial.println("I2c device number error 0x12");
    delay(1000);
  }
  URM09_FRONT.setModeRange(MEASURE_MODE_AUTOMATIC, MEASURE_RANG_500);
  delay(10);

  while (!URM09_LEFT.begin(0x11)) {
    Serial.println("I2c device number error 0x11");
    delay(1000);
  }
  URM09_LEFT.setModeRange(MEASURE_MODE_AUTOMATIC, MEASURE_RANG_500);
  delay(10);

  while (!URM09_RIGHT.begin(0x13)) {
    Serial.println("I2c device number error 0x13");
    delay(1000);
  }
  URM09_RIGHT.setModeRange(MEASURE_MODE_AUTOMATIC, MEASURE_RANG_500);
  delay(10);

  // -------- BNO ------------

  if (!bno.begin()) {  // 0x0C is NDOF mode - not true north
    /* There was a problem detecting the BNO055 ... check your connections */
    Serial.print("Ooops, no BNO055 detected ... Check your wiring or I2C ADDR!");
  }
}

void setMotorSpeed0(int motor_speed, Stream &port) {  // Port is passed as reference as to modify real object
  if (motor_speed < 0) {
    port.write(0x86);            // motor reverse command
    motor_speed = -motor_speed;  // make speed positive
  } else {
    port.write(0x85);  // motor forward command
  }
  port.write(motor_speed & 0x1F);
  port.write(motor_speed >> 5 & 0x7F);
}

void drive0(float ang, float drive_speed) {  // Speed is a decimal

  float radAng = ((45 + ang) / 180) * 3.14159;
  float xSpeed = drive_speed * cos(radAng) * 3200;
  float ySpeed = drive_speed * sin(radAng) * 3200;
  float rotation = constrain(-processed_heading / 90, -1, 1);

  if (switch_on) {
    if (ang > 135 && ang < 315) {  // BL
      if (rotation > 0) {          // Clockwise
        setMotorSpeed(ySpeed, BR_MOT);
        setMotorSpeed(ySpeed - (2 * rotation * ySpeed), TL_MOT);       // Decrease TL rotation
      } else {                                                         // Counter-Clockwise
        setMotorSpeed(ySpeed - (2 * abs(rotation) * ySpeed), BR_MOT);  // Decrease BR rotation
        setMotorSpeed(-1 * ySpeed, TL_MOT);
      }
    } else {               // TR
      if (rotation > 0) {  // Clockwise
        setMotorSpeed(-1 * ySpeed, TL_MOT);
        setMotorSpeed(ySpeed - (2 * rotation * ySpeed), BR_MOT);
      } else {  // Counter-Clockwise
        setMotorSpeed(ySpeed, BR_MOT);
        setMotorSpeed(-1 * (ySpeed - (2 * abs(rotation) * ySpeed)), TL_MOT);  // Decrease TL rotation
      }
    }
    if (ang > 45 && ang < 225) {  // BR
      if (rotation > 0) {         // Clockwise
        setMotorSpeed(xSpeed, TR_MOT);
        setMotorSpeed(-1 * (xSpeed - (2 * rotation * xSpeed)), BL_MOT);
      } else {  // Counter-Clockwise
        setMotorSpeed(xSpeed - (2 * abs(rotation) * xSpeed), TR_MOT);
        setMotorSpeed(-1 * xSpeed, BL_MOT);
      }
    } else {               // TL
      if (rotation > 0) {  // Clockwise
        setMotorSpeed(xSpeed - (2 * rotation * xSpeed), TR_MOT);
        setMotorSpeed(-1 * xSpeed, BL_MOT);
      } else {  // Counter-Clockwise
        setMotorSpeed(-1 * (xSpeed - (2 * abs(rotation) * xSpeed)), BL_MOT);
        setMotorSpeed(xSpeed, TR_MOT);
      }
    }
  } else {
    setMotorSpeed(0, TL_MOT);
    setMotorSpeed(0, TR_MOT);
    setMotorSpeed(0, BL_MOT);
    setMotorSpeed(0, BR_MOT);
  }
  //polarity depends how you wire motors
}
